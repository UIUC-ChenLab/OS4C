
// SPDX-License-Identifier: BSD-2-Clause-Views
/*
 * Copyright (c) 2024 University of Illinois Urbana Champaign
 */

// Language: Verilog 2001

`resetall
`timescale 1ns / 1ps
`default_nettype none

// The purpose of this module is to convert AXIL Addresses Generated by the Linux driver into actual physical addresses
// This is the virtual to physical resource translation logic mentioned in the 2024 IEEE Cloud Paper.
module resource_translator # (
    parameter TOTAL_RESOURCES = 4096, // The number of resources we are virtualizing
	parameter FUNCTION_ID_WIDTH = 8, // Number of functions
	parameter RESOURCE_BIT_WIDTH = 2, // Number of bits per resource (for example, if each resource has a set of relevant addresses)
	parameter AXIL_ADDR_WIDTH = 32 // AXIL Address Width

)
(
    input wire [AXIL_ADDR_WIDTH-1:0] input_read_address,
	input wire [FUNCTION_ID_WIDTH-1:0] input_read_function_id,
	input wire [AXIL_ADDR_WIDTH-1:0] input_write_address,
	input wire [FUNCTION_ID_WIDTH-1:0] input_write_function_id, 


    output wire [AXIL_ADDR_WIDTH-1:0] output_read_address,
	output wire [FUNCTION_ID_WIDTH-1:0] output_read_function_id,
	output wire [AXIL_ADDR_WIDTH-1:0] output_write_address,
	output wire [FUNCTION_ID_WIDTH-1:0] output_write_function_id

);

wire [AXIL_ADDR_WIDTH-1:0] output_read_address_translated;
wire [AXIL_ADDR_WIDTH-1:0] output_write_address_translated;

parameter TOTAL_FUNCS = 2**FUNCTION_ID_WIDTH;

parameter RESOURCES_PER_FUNC = TOTAL_RESOURCES / TOTAL_FUNCS;
parameter RESOURCE_PER_FUNC_BITS = $clog2(RESOURCES_PER_FUNC);
parameter RESOURCE_BITS = RESOURCE_PER_FUNC_BITS + RESOURCE_BIT_WIDTH; // number of bits to keep from the input_address

assign output_read_function_id = input_read_function_id; // pass through to the output
assign output_write_function_id = input_write_function_id; // pass through to output

assign output_read_address_translated = (input_read_function_id << RESOURCE_BITS) | input_read_address[RESOURCE_BITS-1:0]; // calculate the physical resource
assign output_write_address_translated = (input_write_function_id << RESOURCE_BITS) | input_write_address[RESOURCE_BITS-1:0]; // calculate the physical resource


assign output_read_address = (input_read_function_id == 0) ? input_read_address : output_read_address_translated; // only if not function 0, translate the address.
assign output_write_address = (input_write_function_id == 0) ? input_write_address : output_write_address_translated; // only if not function 0, translate the address.


endmodule